#' Inexact dates
#'
#' Incomplete dates cannot be directly coerced into date values in R.
#' These functions help
#'
#' @details
#' `unknown_date` is a vectorized function which implements the non-vectorized
#'   `earliest_date` and `latest_date`.
#' If a split vector of 2 is passed to `unknown_date`, it is assumed that the
#'   vector consists of the Month and Year.
#' If a split vector of 1 is passed to `unknown_date`, it is assumed that the
#'   vector consists only of the Year.
#' For cases in which the year is not provided or the month is unknown, it is
#'   suggested that these be recoded before using this function.
#'
#' The `as_date` parameter is used to allow the `unknown_date` function to work
#'   with a character vector and change the date class at the end
#'
#' @param year Year
#' @param month Month
#' @param day Day
#' @param x a date "string" (see details)
#' @param format A date "format" (see details)
#' @param possible Whether to look at earliest or latest
#' @param invalid_date_string A string (passed as a regular expression; case insensitive)
#'   to be removed from `x`
#' @param as_date Logical, if TRUE will return the output as a date
#'
#' @importFrom stats setNames
#'
#' @name possible_date
#' @export
#' @examples
#' earliest_date(2019, 1, 0)
#' earliest_date(2000)
#' earliest_date(2019, NULL, NULL)
#' earliest_date(2019, NULL, 2)
#' earliest_date(2019, NULL, 31)
#'
#' latest_date(2019)
#' latest_date(2019, NULL, NULL)
#' latest_date(2019, 0)
#' latest_date(2019, NULL, 2)
#' latest_date(2019, 2)
#' latest_date(2016, 2)
#'
#' x <- "UN UNK 2019"
#' unknown_date(x) # NA_date_
#'
#' unknown_date(x, format = "dmy")
#' unknown_date(x, format = "dmy", possible = "l")
#'
#' unknown_date(c("01 JAN 1996", "Feb 2010", "2019"), "dmy")
#' unknown_date(c("01 JAN 1996", "Feb 2016"), "dmy", "latest")
#' unknown_date("2015", possible = "e")
#' unknown_date("2015", possible = "l")

unknown_date <- function(x,
                         format = "ymd",
                         possible = c("earliest", "latest"),
                         invalid_date_string = "^UNK?|NA$") {
  possible <- match.arg(possible)

  form <- strsplit(format, "")[[1]]
  if (anyNA(match(form, c("y", "m", "d")))) {
    stop("Format not assigned correctly: should use 'y', 'm', and 'd'.",
         call. = FALSE)
  }

  res <- vapply(x,
                extract_date,
                character(1),
                form = form,
                possible = possible,
                invalid_date_string = invalid_date_string,
                as_date = FALSE,
                USE.NAMES = FALSE)

  as_date_strptime(res)
}


extract_date <- function(x,
                         form = NULL,
                         possible,
                         invalid_date_string = invalid_date_string,
                         format,
                         as_date = TRUE) {
  if (is.na(x) | gsub("[[:space:]]+|[[:punct:]]+", "", x) == "") {
    if (as_date) {
      return(NA_date_)
    } else {
      return(NA_character_)
    }
  }

  if (is.null(form) & !missing(format)) {
    form <- strsplit(format, "")[[1]]
  }

  x <- strsplit(x, "[^[:alnum:]]")[[1]]
  form <- c("y" = 1, "m" = 2, "d" = 3)[form]
  x[grepl(invalid_date_string, x, ignore.case = TRUE)] <- NA_character_
  x[x == "0"] <- NA_character_
  v <- switch(length(x),
              `1` = insert(c(NA_character_,NA_character_, NA_character_),
                           x, which(names(form) == "y"))[form],
              `2` = insert(x, NA_character_, which(names(form) == "d"))[form],
              `3` = x[form])

  if (!maybe_numeric(v[2])) {
    v[2] <- which_month(v[2])
  }

  switch(possible,
         earliest = earliest_date(year = v[1], month = v[2], day = v[3], as_date = as_date),
         latest = latest_date(year = v[1], month = v[2], day = v[3], as_date = as_date))
}

#' @export
#' @rdname possible_date
earliest_date <- function(year, month = NULL, day = NULL, as_date = TRUE) {
  if (is.na(year) | year < 0) {
    # TODO Add feature to allow for earliest dates?
    if (as_date) {
      return(NA_date_)
    } else {
      return(NA_character_)
    }
  }

  x <- vapply(list(month, day),
              function(xx) {
                if (is.null(xx)) {
                  xx <- "01"
                } else if (is.na(xx) | xx <= 0) {
                  xx <- "01"
                } else {
                  formatC(xx, width = 2, flag = 0)
                }
              },
              character(1),
              USE.NAMES = FALSE)

  res <- paste(c(year, x), collapse = "-")

  if (as_date) {
    as_date_strptime(res)
  } else {
    res
  }
}

#' @export
#' @rdname possible_date
latest_date <- function(year, month = NULL, day = NULL, as_date = TRUE) {
  if (is.na(year)) {
    # TODO Possible feature to allow for max dates?
    # Auto set to current date?  Or just return as NA?
    return(NA_date_)
  }
  year <- as.numeric(year)

  if (is.null(month)) {
    month <- 12
  } else if (is.na(month)) {
    month <- 12
  }

  month <- suppressWarnings(as.numeric(month))

  if (is.na(month) | month <= 0 | month > 12) {
    month <- 12
  }

  cmonth <- formatC(month, width = 2, flag = "0")

  if (is.null(day)) {
    day <- get_days_in_month(year)[month]
  } else if (is.na(day) | day <= 0) {
    day <- get_days_in_month(year)[month]
  }

  res <- paste(year, cmonth, day, sep = "-")

  if (as_date) {
    as_date_strptime(res)
  } else {
    res
  }
}

#' Splits/parses dates
#'
#' Separates dates from a vector or a data.frame
#'
#' @param x A vector or data.frame
#' @param year Name for year column or column suffix
#' @param month Name for month column or column suffix
#' @param day Name for day column or column suffix
#' @param dates_to_row Logical, if `TRUE`, adds dates to the row names
#' @param cols A character vector of the columns to parse into dates
#' @param sep String to use to separate new columns
#' @param keep Logical, if `TRUE` the original date column is kept
#'
#' @examples
#' x <- c("2010-01-12", "2020-09-30", "1999-12-31")
#' split_date(as.Date(x))
#'
#' xx <- data.frame(
#'   x1 = 1:3,
#'   x2 = runif(3),
#'   date1 = as.Date(c("1950-10-05", "2020-04-29", "1992-12-17")),
#'   x3 = letters[1:3],
#'   date2 = as.Date(c("2010-01-12", "2020-09-30", "1999-12-31")))
#' parse_date(xx, c("date1", "date2"))
#' @export
split_date <- function(x, year = "year", month = "month", day = "day",
                       dates_to_row = FALSE) {
  stopifnot(inherits(x, "Date"))
  x %>%
    as.character() %>%
    sapply(strsplit, split = "-", fixed = TRUE, simplify = TRUE) %>%
    lapply(as.integer) %>%
    Reduce(rbind, .) %>%
    as.data.frame(row.names = if (dates_to_row) x else FALSE,
                  stringsAsFactors = FALSE) %>%
    setNames(c(year, month, day))
}

#' @export
#' @rdname split_date
parse_date <- function(x, cols, year = "year", month = "month", day = "day",
                       sep = "_", keep = FALSE) {
  stopifnot(is.data.frame(x) && all(cols %in% colnames(x)))

  for (i in cols) {
    if (!inherits(x, "Date")) {
      warning(paste0("Column `", i, "` is not a Date -- skipped"),
              call. = FALSE)
      next
    }

    cn <- colnames(x)
    place <- which(cn == i) - !keep
    after <- colnames(x)[-seq(place + !keep)]
    x <- cbind(x[, seq(place), drop = FALSE],
               split_date(x[[i]],
                          year = sprintf("%s%s%s", i, sep, year),
                          month = sprintf("%s%s%s", i, sep, month),
                          day = sprintf("%s%s%s", i, sep, day),
                          dates_to_row = FALSE),
               x[, after, drop = FALSE])
  }
  x
}


# Utils -------------------------------------------------------------------

days_in_month <- setNames(
  c(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31),
  month.abb)

is_leap <- function(year = NULL) {
  if (year %% 4 != 0) {
    FALSE
  } else if (year %% 100 != 0) {
    TRUE
  } else if (year %% 400 != 0) {
    FALSE
  } else {
    TRUE
  }
}

get_days_in_month <- function(year = NULL) {
  if (is_leap(year)) {
    days_in_month['Feb'] <- 29
  }

  days_in_month
}

month_abb <- tolower(month.abb)

which_month <- function(month_abbreviation) {
  x <- which(month_abb == tolower(month_abbreviation))

  if (length(x) == 0) {
    return(NA_integer_)
  }

  x
}

NA_date_ <- as.Date(NA)

# To be set on package load
options(dirtyr.tz = Sys.timezone())

as_date_strptime <- function(x) {
  as.Date(strptime(x,
                   format = "%Y-%m-%d",
                   tz = getOption("dirtyr.tz", "GMT")),
          format = "%Y-%m-%d")
}
